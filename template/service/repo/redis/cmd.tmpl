package redis

import (
	"context"
	"encoding/json"
	"time"
)

type Commander interface {
    MGet(ctx context.Context, keys ...string) ([]interface{}, error)
    Scan(data []interface{}, dst interface{}) error
    MSet(ctx context.Context, keyValues map[string]interface{}, duration time.Duration) error
    Del(ctx context.Context, keys ...string) error
}

type Cmd struct {
}

func NewCmd() Cmd {
	return Cmd{}
}

func (r *Cmd) MGet(ctx context.Context, keys ...string) ([]interface{}, error) {
	return Client.WithContext(ctx).MGet(keys...).Result()
}

func (r *Cmd) Scan(data []interface{}, dst interface{}) error {
	b, _ := json.Marshal(data)
	return json.Unmarshal(b, dst)
}

func (r *Cmd) MSet(ctx context.Context, keyValues map[string]interface{}, duration time.Duration) error {
	var pairs []interface{}
	var ttlCmd []interface{}
	ttlCmd = append(ttlCmd, "MULTI")
	for k, v := range keyValues {
		pairs = append(pairs, k, v)
		ttlCmd = append(ttlCmd, "EXPIRE", k, duration.Seconds())
	}
	ttlCmd = append(ttlCmd, "EXEC")

	if err := Client.WithContext(ctx).MSet(pairs).Err(); err != nil {
		return err
	}
	return Client.WithContext(ctx).Do(ttlCmd).Err()
}

func (r *Cmd) Del(ctx context.Context, keys ...string) error {
	return Client.WithContext(ctx).Del(keys...).Err()
}
