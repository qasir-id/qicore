package pubsub

import (
	"context"
	"log"
	"sync"

	"{{.ProjectName}}/transport/pubsub/server"

	"gitlab.com/qasir/web/project/qasircore.git/logger"

	"github.com/jinzhu/gorm"

	psg "cloud.google.com/go/pubsub"
	"github.com/qasir-id/qistream/service/pubsub"
	"github.com/tidwall/gjson"
	"go.elastic.co/apm"
)

type PubSub struct {
	db *gorm.DB
}

func NewPubSubService(db *gorm.DB) *PubSub {
	return &PubSub{
		db: db,
	}
}

func (ps *PubSub) Run() {
	log.Println("â‡¨ Starting [Pub/Sub] Client !!")
	// RUN service PubSub
	pubsub.Source = "{{.ProjectName}}"
	psService := pubsub.NewPubSubService(ps.db, pubsub.NewClient())
	if err := psService.AsyncPull(func(ctx context.Context, msg *psg.Message) {
		var mu sync.Mutex
		func() {
			mu.Lock()
			var errs []string
			dataJson := string(msg.Data)
			// defer psService.SaveLog(msg, errs, mu)
			//put your code String here
			action := gjson.Get(dataJson, "action").String()
			apmTx := apm.DefaultTracer.StartTransaction(action, "request")
			defer func() {
				apmTx.End()
				mu.Unlock()
			}()
			ctx = apm.ContextWithTransaction(ctx, apmTx)
			if f, ok := server.ServiceMapping[action]; ok {
				if _, err := f.Handle(ctx, msg.Attributes, msg.Data); err != nil {
					logger.LogEntry(ctx).WithError(err).Errorf("[PUB/SUB] %s has an error : %s ", action, err.Error())
					errs = append(errs, err.Error())
				}
			} else {
				logger.LogEntry(ctx).Error("[PUB/SUB] invalid action ", action)
				errs = append(errs, "Type Not Found")
			}
			//acknowledge message
			msg.Ack()
			log.Println("Ack()")
		}()
	}); err != nil {
		log.Fatalf("Failed to pull pub/sub message : %v", err)
	}
}
