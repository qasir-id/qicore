package util

import (
	"bytes"
	"fmt"
	"reflect"
	"strings"

	"github.com/olivere/elastic/v7"
)

// Query struct binder for default query param
type Query struct {
	Sort   string `json:"sort"`
	Filter map[string]interface{}
}

// NewQuery initiate query
func NewQuery(sort string, filter map[string]interface{}) *Query {
	return &Query{
		Sort:   sort,
		Filter: filter,
	}
}

// Operator string transalation
var Operator = map[string]string{
	"gt":      ">",      // elastic
	"lt":      "<",      // elastic
	"eq":      "=",      // elastic
	"ne":      "!=",     // elastic
	"gte":     ">=",     // elastic
	"lte":     "<=",     // elastic
	"like":    "like",   // elastic - text search
	"in":      "in",     // elastic
	"any":     "any",    // elastic / postgres
	"notin":   "not in", // elastic
	"null":    "is null",
	"notnull": "is not null",
	"is":      "is",
}

// Where generate sql WHERE statement ,with format
//		key :"{columnName}{$operator}"
//		value : interface
// with default operator value "$eq"
// for example :
//     "amount$gte": 19200.00
// 	   "status": 1
// will be translated into sql format :
// 		WHERE amount >= 19200.00
//		AND status = 1
func (q *Query) Where() (string, []interface{}) {
	query := new(bytes.Buffer)
	var args []interface{}
	i := 0
	for k, v := range q.Filter {
		fields := strings.Split(k, "$")
		columnName := fields[0]
		opr := translateOperator(fields[1])
		isRequire := func(s string) bool {
			return s[len(s)-1:] == "!"
		}(fields[1])
		if i == 0 {
			isNull, _ := IsArgNil(v)
			//log.Println("QIBO ::", columnName, opr, isRequire, isNull, r.String(), isRequire || !isNull)
			if isRequire || !isNull {
				switch opr {
				case Operator["null"], Operator["notnull"]:
					query.WriteString(` WHERE ` + columnName + ` ` + opr)
				case Operator["like"]:
					tmpArgs, ok := v.(string)
					if ok {
						query.WriteString(` WHERE lower(` + columnName + `) ` + opr + ` concat('%` + strings.ToLower(tmpArgs) + `%') `)
					}
					// args = append(args, strings.ToLower(tmpArgs))
				case Operator["in"]:
					s := reflect.ValueOf(v)
					if s.Len() > 0 {
						if s.Kind() == reflect.Slice {
							var smt string
							for j := 0; j < s.Len(); j++ {
								smt += `?,`
								switch s.Index(j).Kind() {
								case reflect.Int:
									args = append(args, s.Index(j).Int())
								case reflect.Int32:
									args = append(args, s.Index(j).Int())
								case reflect.Int64:
									args = append(args, s.Index(j).Int())
								case reflect.Float32:
									args = append(args, s.Index(j).Float())
								case reflect.Float64:
									args = append(args, s.Index(j).Float())
								default:
									args = append(args, s.Index(j).String())
								}
							}
							query.WriteString(` WHERE ` + columnName + ` ` + opr + `(` + smt[:len(smt)-1] + `)`)
						}
					} else {
						args = append(args, nil)
						query.WriteString(` WHERE ` + columnName + ` ` + opr + `( ? )`)
					}
					// query.WriteString(` WHERE ` + columnName + ` ` + opr + ` (?) `)
					// args = append(args, v)
				case Operator["any"]:
					s := reflect.ValueOf(v)
					if s.Kind() == reflect.Slice {
						if s.Len() > 0 {
							for j := 0; j < s.Len(); j++ {
								if j == 0 {
									query.WriteString(` WHERE '` + s.Index(j).String() + `' = ` + opr + `(` + columnName + `)`)
								} else {
									query.WriteString(` AND '` + s.Index(j).String() + `' = ` + opr + `(` + columnName + `)`)
								}
							}
						}
					}
				default:
					query.WriteString(` WHERE ` + columnName + ` ` + opr + ` ? `)
					args = append(args, v)
				}
			} else {
				query.WriteString(` WHERE 1 = 1 `)
			}

		} else {
			isNull, _ := IsArgNil(v)
			//log.Println("QIBO ::", columnName, opr, isRequire, isNull, r.String(), isRequire || !isNull)
			if isRequire || !isNull {
				switch opr {
				case Operator["null"], Operator["notnull"]:
					query.WriteString(` AND ` + columnName + ` ` + opr)
				case Operator["like"]:
					tmpArgs, ok := v.(string)
					if ok {
						query.WriteString(` AND lower(` + columnName + `) ` + opr + ` concat('%` + strings.ToLower(tmpArgs) + `%') `)
					}
				case Operator["in"]:
					s := reflect.ValueOf(v)
					// log.Println("QIBO lengh of slice", s.Len())
					if s.Kind() == reflect.Slice {
						var smt string
						if s.Len() > 0 {
							for j := 0; j < s.Len(); j++ {
								smt += `?,`
								switch s.Index(j).Kind() {
								case reflect.Int:
									args = append(args, s.Index(j).Int())
								case reflect.Int32:
									args = append(args, s.Index(j).Int())
								case reflect.Int64:
									args = append(args, s.Index(j).Int())
								case reflect.Float32:
									args = append(args, s.Index(j).Float())
								case reflect.Float64:
									args = append(args, s.Index(j).Float())
								default:
									args = append(args, s.Index(j).String())
								}
							}
							query.WriteString(` AND ` + columnName + ` ` + opr + `(` + smt[:len(smt)-1] + `)`)
						} else {
							args = append(args, nil)
							query.WriteString(` WHERE ` + columnName + ` ` + opr + `( ? )`)
						}
					}
				case Operator["any"]:
					s := reflect.ValueOf(v)
					if s.Kind() == reflect.Slice {
						if s.Len() > 0 {
							for j := 0; j < s.Len(); j++ {
								query.WriteString(` AND '` + s.Index(j).String() + `' = ` + opr + `(` + columnName + `)`)
							}
						}
					}
				default:
					query.WriteString(` AND ` + columnName + ` ` + opr + ` ? `)
					args = append(args, v)
				}
			} else {
				query.WriteString(` AND 1 = 1 `)
			}
		}
		i++
	}
	return query.String(), args
}

// Order generate string ordering query statement
func (q *Query) Order() string {
	if len(q.Sort) > 0 {
		field := strings.Split(q.Sort, ",")
		sort := ` ORDER BY `
		for _, v := range field {
			sortType := func(str string) string {
				if strings.HasPrefix(str, "-") {
					return `desc`
				}
				return `asc`
			}
			sort += strings.TrimPrefix(v, "-") + ` ` + sortType(v) + `,`
		}
		return sort[:len(sort)-1]
	}
	return ` `
}

func (q *Query) ElasticSort() []elastic.Sorter {
	var sort []elastic.Sorter
	if len(q.Sort) > 0 {
		fields := strings.Split(q.Sort, ",")
		for _, v := range fields {
			fs := elastic.NewFieldSort(strings.TrimPrefix(v, "-"))
			if strings.HasPrefix(v, "-") {
				fs.Desc()
			} else {
				fs.Asc()
			}
			sort = append(sort, fs)
		}
		return sort
	}
	sort = append(sort, elastic.NewFieldSort("id").Desc())
	return sort
}

func (q *Query) ElasticQuery() elastic.Query {
	boolQuery := elastic.NewBoolQuery()
	var path string
	for k, v := range q.Filter {
		fields := strings.Split(k, "$")
		columnName := fields[0]
		opr := strings.Trim(fields[1], "!")
		if len(fields) > 2 {
			path = fields[2]
		}
		isRequire := func(s string) bool {
			return s[len(s)-1:] == "!"
		}(fields[1])
		isNull, kind := IsArgNil(v)
		// log.Println("field ", isRequire, !isNull, kind, v, columnName)
		if isRequire || !isNull {
			switch opr {
			case "like":
				// boolQuery = boolQuery.Must(
				// 	elastic.NewFuzzyQuery(columnName, v).
				// 		Transpositions(true).
				// 		Fuzziness("AUTO").
				// 		Rewrite("constant_score"))
				boolQuery = boolQuery.Must(elastic.NewMatchQuery(columnName, v))

			case "gt":
				boolQuery = boolQuery.Must(elastic.NewRangeQuery(columnName).Gt(v))
			case "gte":
				boolQuery = boolQuery.Must(elastic.NewRangeQuery(columnName).Gt(v))
			case "lt":
				boolQuery = boolQuery.Must(elastic.NewRangeQuery(columnName).Lt(v))
			case "lte":
				boolQuery = boolQuery.Must(elastic.NewRangeQuery(columnName).Lte(v))
			case "ne", "notin":
				boolQuery = boolQuery.MustNot(elastic.NewTermsQuery(columnName, v))
			default:
				if kind == reflect.Slice {
					var tmp []interface{}
					var tmpStr []string
					s := reflect.ValueOf(v)
					for i := 0; i < s.Len(); i++ {
						s.Len()
						tmp = append(tmp, fmt.Sprint(s.Index(i)))
						tmpStr = append(tmpStr, fmt.Sprint(s.Index(i)))
					}
					if columnName == "ids" || columnName == "id" {
						boolQuery = boolQuery.Must(
							elastic.NewIdsQuery("_doc").
								Ids(tmpStr...),
						)
					} else {
						boolQuery = boolQuery.Must(elastic.NewTermsQuery(columnName, tmp...))
					}
				} else {
					boolQuery = boolQuery.Must(elastic.NewTermsQuery(columnName, v))
				}
			}
		}
	}
	if path != "" {
		return elastic.NewNestedQuery(path, boolQuery)
	}
	return boolQuery
}

func translateOperator(s string) string {
	str := strings.Trim(s, "!")
	operator := Operator[strings.ToLower(str)]
	if operator == "" {
		return Operator["eq"]
	}
	return operator
}

func IsArgNil(i interface{}) (bool, reflect.Kind) {
	r := reflect.ValueOf(i)
	switch r.Kind() {
	case reflect.Slice:
		return r.Len() == 0, reflect.Slice
	case reflect.String:
		return r.String() == "", reflect.String
	case reflect.Int:
		return r.Int() == 0, reflect.Int
	case reflect.Int32:
		return r.Int() == 0, reflect.Int32
	case reflect.Int64:
		return r.Int() == 0, reflect.Int64
	case reflect.Float32:
		return r.Float() == 0, reflect.Float32
	case reflect.Float64:
		return r.Float() == 0, reflect.Float64
	default:
		return false, reflect.String
	}
}
